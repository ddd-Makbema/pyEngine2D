{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to pyEngine (seperate from pyEngine3D) docs These docs will contain the functions nessesary to write 2D games in the engine with definitions of many main terms. These docs are orginized into general folders of topics such as the physics engine or basic rendering.","title":"Welcome to pyEngine (seperate from pyEngine3D) docs"},{"location":"#welcome-to-pyengine-seperate-from-pyengine3d-docs","text":"These docs will contain the functions nessesary to write 2D games in the engine with definitions of many main terms. These docs are orginized into general folders of topics such as the physics engine or basic rendering.","title":"Welcome to pyEngine (seperate from pyEngine3D) docs"},{"location":"docs/","text":"pyEngine2D Welcome Welcome to pyEngine docs (seperate from pyEngine3D) These docs will contain the functions nessesary to write 2D games in the engine with definitions of many main terms. These docs are orginized into general folders of topics such as the physics engine or basic rendering. Getting Started 1: Use the package manager pip to install pygame to allow it to work. pip install pygame 2: look at Variables to see the basics of how to initialize game objects 3: learn how to write scripts, add media and initialize game objects by making a basic pong game in the Tutorial 4: for indepth descriptions of how the engine works look at MainFiles 5: to look at what attributes are in the builtin scripts and also what they do, look at Builtins","title":"pyEngine2D"},{"location":"docs/#pyengine2d","text":"","title":"pyEngine2D"},{"location":"docs/#welcome","text":"Welcome to pyEngine docs (seperate from pyEngine3D) These docs will contain the functions nessesary to write 2D games in the engine with definitions of many main terms. These docs are orginized into general folders of topics such as the physics engine or basic rendering.","title":"Welcome"},{"location":"docs/#getting-started","text":"1: Use the package manager pip to install pygame to allow it to work. pip install pygame 2: look at Variables to see the basics of how to initialize game objects 3: learn how to write scripts, add media and initialize game objects by making a basic pong game in the Tutorial 4: for indepth descriptions of how the engine works look at MainFiles 5: to look at what attributes are in the builtin scripts and also what they do, look at Builtins","title":"Getting Started"},{"location":"docs/Definitions/","text":"Definitions Game Engine Terminology GameObject The main objects manipulated during runtime Used for: - Event handling - Rendering images on the screen - Calling other scripts Screen Where the game is rendered Transform Attributes Parent Larger definition found in parent Set as the origin for where the image is rendered multiplies the scale by the parent's scale adds the rotation to the parent's rotation adds the coords of the image to the parent's when the parent is rotated the child is rotated around it Sprite The image loaded and transformed that is put on the screen Frame/FPS The Screen refreshing to update with physics and other changes Fps is how fast the updates happen Fixed FPS Will be ran a set amount of times a second. Good for physics and computations where you do not want everything to go super speedy if someone is using a faster computer Physics Frame Based off of the fixed fps, can run multiple times before the next frame is ran to catch up, used to make sure physics is consistent between machines with different hardware speeds.","title":"Definitions"},{"location":"docs/Definitions/#definitions","text":"","title":"Definitions"},{"location":"docs/Definitions/#game-engine-terminology","text":"","title":"Game Engine Terminology"},{"location":"docs/Definitions/#gameobject","text":"The main objects manipulated during runtime Used for: - Event handling - Rendering images on the screen - Calling other scripts","title":"GameObject"},{"location":"docs/Definitions/#screen","text":"Where the game is rendered","title":"Screen"},{"location":"docs/Definitions/#transform","text":"Attributes","title":"Transform"},{"location":"docs/Definitions/#parent","text":"Larger definition found in parent Set as the origin for where the image is rendered multiplies the scale by the parent's scale adds the rotation to the parent's rotation adds the coords of the image to the parent's when the parent is rotated the child is rotated around it","title":"Parent"},{"location":"docs/Definitions/#sprite","text":"The image loaded and transformed that is put on the screen","title":"Sprite"},{"location":"docs/Definitions/#framefps","text":"The Screen refreshing to update with physics and other changes Fps is how fast the updates happen","title":"Frame/FPS"},{"location":"docs/Definitions/#fixed-fps","text":"Will be ran a set amount of times a second. Good for physics and computations where you do not want everything to go super speedy if someone is using a faster computer","title":"Fixed FPS"},{"location":"docs/Definitions/#physics-frame","text":"Based off of the fixed fps, can run multiple times before the next frame is ran to catch up, used to make sure physics is consistent between machines with different hardware speeds.","title":"Physics Frame"},{"location":"docs/Builtins/RigidBody2D/","text":"RigidBody2D Not constructed yet","title":"RigidBody2D"},{"location":"docs/Builtins/RigidBody2D/#rigidbody2d","text":"Not constructed yet","title":"RigidBody2D"},{"location":"docs/Builtins/Transform/","text":"Transform Handles the movement of the game object and how that image will look when rendered on the screen. The main 3 attributes for each game object are transform, scale, and rotation. Attributes User Set Attribute discription transform where on the screen the image will render, by default (-1,-1) so it will appear off the screen scale how much to scale the image. By default (1,1) so each pixel in the image will be one pixel on the screen. rotation how much to rotate the image from straight up and down in degrees. By default 0 Auto filled/passed Attribute discription game_object auto-passed-in. The instance of the game object that this class instance is a part of last_scale used to store the scale of the game object last physics frame. Look to efficient_scaling for why this is last_parent_scale same as last_scale but for the instance of the parent game object previous_scale stores the scale that is returned from the _scale method and used to check for changes in the scale over time size the height and width in pixels of the raw image load rotated and scaled image ready to be blit'ed onto the screen center transformed coords for the image accounting for the parent's game object final_scale the scaling amount actually used on the image to scale it Efficient Scaling To not have to recalculate the scale of the image every frame, a check is run to see if the scale has changed from what it was the last frame. If it or the scale of the parent has not changed, then the final_scale value will remain the same as the last frame. Methods Method discription start Grabs the size value of the image. Done in start to make sure the image has been instantiated before trying to get the size update Gets the transformed image accounting for rotation and scale add_transform takes in x and y and adds them to the transform value to allow screen movement parent_transform Transforms the coords to account for the transform of the parent game object. Calls the _rotate_transform method to do this. Fills the center attribute here. _rotate_transform takes in the rotation of the parent game object, and the (x,y) coords of the game object multiplied by the scale value of the parent to normalize for the scaling of the parent and gives the coords to rotate the child game object around the parent. _f_scale Gets the scale value using the _scale method and transforms the raw image first by scaling it then by rotating it and returns that image. Uses the builtin pyGame methods transform.scale and rotate to do this _scale First checks if the scale or the parent scale has changed from last frame and if so returns the last final_scale amount. If not then runs _parent_scale and saves the value to previous_scale and updates _last_parent_scale to ready for next frame. _parent_scale for the x and y scale values each, it multiplies the size (pixel amount) by the scale (for the child) by the scale (for the parent) and returns it","title":"Transform"},{"location":"docs/Builtins/Transform/#transform","text":"Handles the movement of the game object and how that image will look when rendered on the screen. The main 3 attributes for each game object are transform, scale, and rotation.","title":"Transform"},{"location":"docs/Builtins/Transform/#attributes","text":"","title":"Attributes"},{"location":"docs/Builtins/Transform/#user-set","text":"Attribute discription transform where on the screen the image will render, by default (-1,-1) so it will appear off the screen scale how much to scale the image. By default (1,1) so each pixel in the image will be one pixel on the screen. rotation how much to rotate the image from straight up and down in degrees. By default 0","title":"User Set"},{"location":"docs/Builtins/Transform/#auto-filledpassed","text":"Attribute discription game_object auto-passed-in. The instance of the game object that this class instance is a part of last_scale used to store the scale of the game object last physics frame. Look to efficient_scaling for why this is last_parent_scale same as last_scale but for the instance of the parent game object previous_scale stores the scale that is returned from the _scale method and used to check for changes in the scale over time size the height and width in pixels of the raw image load rotated and scaled image ready to be blit'ed onto the screen center transformed coords for the image accounting for the parent's game object final_scale the scaling amount actually used on the image to scale it","title":"Auto filled/passed"},{"location":"docs/Builtins/Transform/#efficient-scaling","text":"To not have to recalculate the scale of the image every frame, a check is run to see if the scale has changed from what it was the last frame. If it or the scale of the parent has not changed, then the final_scale value will remain the same as the last frame.","title":"Efficient Scaling"},{"location":"docs/Builtins/Transform/#methods","text":"Method discription start Grabs the size value of the image. Done in start to make sure the image has been instantiated before trying to get the size update Gets the transformed image accounting for rotation and scale add_transform takes in x and y and adds them to the transform value to allow screen movement parent_transform Transforms the coords to account for the transform of the parent game object. Calls the _rotate_transform method to do this. Fills the center attribute here. _rotate_transform takes in the rotation of the parent game object, and the (x,y) coords of the game object multiplied by the scale value of the parent to normalize for the scaling of the parent and gives the coords to rotate the child game object around the parent. _f_scale Gets the scale value using the _scale method and transforms the raw image first by scaling it then by rotating it and returns that image. Uses the builtin pyGame methods transform.scale and rotate to do this _scale First checks if the scale or the parent scale has changed from last frame and if so returns the last final_scale amount. If not then runs _parent_scale and saves the value to previous_scale and updates _last_parent_scale to ready for next frame. _parent_scale for the x and y scale values each, it multiplies the size (pixel amount) by the scale (for the child) by the scale (for the parent) and returns it","title":"Methods"},{"location":"docs/Builtins/Collisions/Colliders2D/","text":"Colliders2D Not constructed yet","title":"Colliders2D"},{"location":"docs/Builtins/Collisions/Colliders2D/#colliders2d","text":"Not constructed yet","title":"Colliders2D"},{"location":"docs/Builtins/Collisions/CollisionHandler/","text":"CollisionHandler Not constructed yet","title":"CollisionHandler"},{"location":"docs/Builtins/Collisions/CollisionHandler/#collisionhandler","text":"Not constructed yet","title":"CollisionHandler"},{"location":"docs/MainFiles/Exceptions/","text":"Exceptions Sprite name error Raised in game object when the user enters a file name of an image that does not exist. Usually raised due to a spelling mistake in the instantiation of the game object, or removal of the image from the data folder. Parent error Raised when the game object you are trying to call as a parent does not exist. Usually raised due to a spelling mistake in the instantiation of the game object.","title":"Exceptions"},{"location":"docs/MainFiles/Exceptions/#exceptions","text":"","title":"Exceptions"},{"location":"docs/MainFiles/Exceptions/#sprite-name-error","text":"Raised in game object when the user enters a file name of an image that does not exist. Usually raised due to a spelling mistake in the instantiation of the game object, or removal of the image from the data folder.","title":"Sprite name error"},{"location":"docs/MainFiles/Exceptions/#parent-error","text":"Raised when the game object you are trying to call as a parent does not exist. Usually raised due to a spelling mistake in the instantiation of the game object.","title":"Parent error"},{"location":"docs/MainFiles/GameLoop/","text":"Main Game Loop The top level where the program runs. This is what is called when the game is run. game_loop Main function call in the whole program. Begins by calling the start method in all previously instantiated game objects. Then starts the game loop itself. The loop will follow this order 1: Check if the python window has been closed and if so end the program. 2: Calles fixed_update however many times is nessesary to catch up to the current time. 3: Calls update once and only once. 4: Waits until the time the frame should be over using the default python screen.clock.tick. 5: Adds the time the loop has taken to the timer variable to be able to call fixed update the right amount of time. update Renders the screen and calls the update function for all game objects. 1: Fills the screen with a default color: currently lime green will later be able to be user defined. 2: Checks if the pygame window has been closed and if so ends the program. 3: calls the update method for every game object. 4: Takes the transform of the game object and blits the game object onto the screen at those coords. If the transform script is not attached, then it will render it at (-1,-1) so it remains off screen. 5: calls screen.frame_end fixed_update Just calls the fixed update method for every game object delta_time Returns the time since the function has been called last.","title":"Main Game Loop"},{"location":"docs/MainFiles/GameLoop/#main-game-loop","text":"The top level where the program runs. This is what is called when the game is run.","title":"Main Game Loop"},{"location":"docs/MainFiles/GameLoop/#game_loop","text":"Main function call in the whole program. Begins by calling the start method in all previously instantiated game objects. Then starts the game loop itself. The loop will follow this order 1: Check if the python window has been closed and if so end the program. 2: Calles fixed_update however many times is nessesary to catch up to the current time. 3: Calls update once and only once. 4: Waits until the time the frame should be over using the default python screen.clock.tick. 5: Adds the time the loop has taken to the timer variable to be able to call fixed update the right amount of time.","title":"game_loop"},{"location":"docs/MainFiles/GameLoop/#update","text":"Renders the screen and calls the update function for all game objects. 1: Fills the screen with a default color: currently lime green will later be able to be user defined. 2: Checks if the pygame window has been closed and if so ends the program. 3: calls the update method for every game object. 4: Takes the transform of the game object and blits the game object onto the screen at those coords. If the transform script is not attached, then it will render it at (-1,-1) so it remains off screen. 5: calls screen.frame_end","title":"update"},{"location":"docs/MainFiles/GameLoop/#fixed_update","text":"Just calls the fixed update method for every game object","title":"fixed_update"},{"location":"docs/MainFiles/GameLoop/#delta_time","text":"Returns the time since the function has been called last.","title":"delta_time"},{"location":"docs/MainFiles/Screen/","text":"Screen Starts the screen for the game and initializes default variables. Attributes attribute discription width The width in pixels of the game screen by default. It can be still set to fullscreen height The height in pixels of the game screen by default. It can still be set to fullscreen fixed_fps/ffps How fast the physics updates. will remain eventually consistent no matter the speed of the computer fps How fast the screen updates. Can be variable but aims for the set amount name_window The name displayed at the top of the screen and in the taskbar icon Image from the data folder displayed at the top left of the window. does not change the image in the taskbar screen Instance of the screen loaded from pygame clock Instance of the clock class loaded from pygame allows fps monitering start_velocity default value of (0,0) to put in for velocity white rgb value for white to easily color shapes or fill the backround of the screen with black same but for black red same but for red green same but for green blue same but for blue Functions frame_end: Updates the screen for the new frame Usage Users should not have to touch the frame_end function. Users shold, though, feel free to access the Screen class when adding basic shapes to the screen and accessing the colors.","title":"Screen"},{"location":"docs/MainFiles/Screen/#screen","text":"Starts the screen for the game and initializes default variables.","title":"Screen"},{"location":"docs/MainFiles/Screen/#attributes","text":"attribute discription width The width in pixels of the game screen by default. It can be still set to fullscreen height The height in pixels of the game screen by default. It can still be set to fullscreen fixed_fps/ffps How fast the physics updates. will remain eventually consistent no matter the speed of the computer fps How fast the screen updates. Can be variable but aims for the set amount name_window The name displayed at the top of the screen and in the taskbar icon Image from the data folder displayed at the top left of the window. does not change the image in the taskbar screen Instance of the screen loaded from pygame clock Instance of the clock class loaded from pygame allows fps monitering start_velocity default value of (0,0) to put in for velocity white rgb value for white to easily color shapes or fill the backround of the screen with black same but for black red same but for red green same but for green blue same but for blue","title":"Attributes"},{"location":"docs/MainFiles/Screen/#functions","text":"frame_end: Updates the screen for the new frame","title":"Functions"},{"location":"docs/MainFiles/Screen/#usage","text":"Users should not have to touch the frame_end function. Users shold, though, feel free to access the Screen class when adding basic shapes to the screen and accessing the colors.","title":"Usage"},{"location":"docs/MainFiles/Variables/","text":"Variables One of the main files that the user interacts with. This is where the user initializes the Screen and Game Objects Initializing The Objects In depth explanations of both methods can be found in game objects and Screen In short to make a new game object you need to just run the function, no need to save it as a variable. #GameObject(name ,screen, sprite, parent, packages) GameObject(\"test_object\" ,screen.screen, \"test.png\", \"origin\", \"transform.Transform\") For the screen, you do need to save it as a variable, \"screen\" # screen = Init(width, height, fps, ffps, icon, name_window) screen = Init(300, 280, 60, 100, \"test.png\", \"myGame\") Loading Scripts To load a new script, make sure the script is in the \"user\" folder in \"scripts\" Then after the \"parent\" paramater, add as many scripts as you would like by listing the file its in then the class name. eg. \"transform.Transform\" or \"Collider2D.RectangleCollider2D\" Setting the Attributes To set the attributes, you need to call the name you set the game object to when initializing it from a list. Then you can call the class using an attribute added to the game object class which is an instance of the script class. Using that you can access and modify all the attributes of the script. GO.GAME_OBJECTS[\"test_object\"].Transform.rotation = 90","title":"Variables"},{"location":"docs/MainFiles/Variables/#variables","text":"One of the main files that the user interacts with. This is where the user initializes the Screen and Game Objects","title":"Variables"},{"location":"docs/MainFiles/Variables/#initializing-the-objects","text":"In depth explanations of both methods can be found in game objects and Screen In short to make a new game object you need to just run the function, no need to save it as a variable. #GameObject(name ,screen, sprite, parent, packages) GameObject(\"test_object\" ,screen.screen, \"test.png\", \"origin\", \"transform.Transform\") For the screen, you do need to save it as a variable, \"screen\" # screen = Init(width, height, fps, ffps, icon, name_window) screen = Init(300, 280, 60, 100, \"test.png\", \"myGame\")","title":"Initializing The Objects"},{"location":"docs/MainFiles/Variables/#loading-scripts","text":"To load a new script, make sure the script is in the \"user\" folder in \"scripts\" Then after the \"parent\" paramater, add as many scripts as you would like by listing the file its in then the class name. eg. \"transform.Transform\" or \"Collider2D.RectangleCollider2D\"","title":"Loading Scripts"},{"location":"docs/MainFiles/Variables/#setting-the-attributes","text":"To set the attributes, you need to call the name you set the game object to when initializing it from a list. Then you can call the class using an attribute added to the game object class which is an instance of the script class. Using that you can access and modify all the attributes of the script. GO.GAME_OBJECTS[\"test_object\"].Transform.rotation = 90","title":"Setting the Attributes"},{"location":"docs/MainFiles/GameObject/GameObject/","text":"Game Object Main class to hold all the event handlers of the engine including user made packages. More in depth This is where the hub of most of your game will run. This has built in functions that are called from main or packages such as colliders. When these functions are called, they will rarely do anything on their own, but instead try to call the function for all the packages listed in that game object. For each package, it will see if it has that package and if so, run the function in that package. It also currently takes care of handling the sprite using the information given from transform and giving the rendering information to the main loop . Eventually this feature will be moved to its own package in builtins , but that has not happened yet. Attributes Class Attributes Attribute discription INSTANCES A list of all the instances of game objects NAMES A list of the user-input names of the game objects GAME_OBJECTS A dictionary allowing the user to lookup any instance using any name Instance Attributes Attribute discription name The name this game object will be referenced by screen The instance of the screen loaded from the screen sprite The file path of the sprite to load from the data folder parent Transforms the game object to this game object's local scale packages All the user made or builtin packages in the scripts folder to put in for this game object Auto-set Attribute discription image_start The original image loaded from data with no transforms on it package_instances list of all the instances of packages to turn them into attributes parent_instance the instance of the parent game object to access its transform and other key values Methods Method discription init sets most class attributes and imports scripts start Initializes the sprite and loads the instance of the parent also calls the start method in all scripts update called each frame from the MainGameLoop will call update method in all scripts fixed_update called each physicsFrame , will have eventual consistency so it is good for physics, calls fixed_update method in all scripts on_collision_enter called by the collision handler, calls on_collision_enter for the scripts on_trigger_enter same as collision enter but for trigger boxes _import_class_from_string takes in two strings containing the file path for the script, either from builtins or user folders, returns the instance of the script specified by the input string. will search the user folder first then the builtins. _pyLoad takes in the file path of the image stored in the data folder and returns the image loaded using pyGame and the convert_alpha() method to make it transparent so it doesnt show up as a rectangle Instantiating the class To instantiate the class, the arguments are passed in as follows: Attribute Result name string of the name that the game object will be called in the dictionary of all game objects screen should be the same for all game objects, screen.screen, from when the screen was instantiated. This is where the game object will be rendered sprite file name of the image that you want displayed for the game object. No need to put the full filepath, just make sure to put the image in the data folder. parent By default, this is set to origin, which causes all inputs to directly transform to screen cords. this is the name of the game object you wish to have as the parent if you want one. args all the scripts you want to add to the game object","title":"Game Object"},{"location":"docs/MainFiles/GameObject/GameObject/#game-object","text":"Main class to hold all the event handlers of the engine including user made packages.","title":"Game Object"},{"location":"docs/MainFiles/GameObject/GameObject/#more-in-depth","text":"This is where the hub of most of your game will run. This has built in functions that are called from main or packages such as colliders. When these functions are called, they will rarely do anything on their own, but instead try to call the function for all the packages listed in that game object. For each package, it will see if it has that package and if so, run the function in that package. It also currently takes care of handling the sprite using the information given from transform and giving the rendering information to the main loop . Eventually this feature will be moved to its own package in builtins , but that has not happened yet.","title":"More in depth"},{"location":"docs/MainFiles/GameObject/GameObject/#attributes","text":"","title":"Attributes"},{"location":"docs/MainFiles/GameObject/GameObject/#class-attributes","text":"Attribute discription INSTANCES A list of all the instances of game objects NAMES A list of the user-input names of the game objects GAME_OBJECTS A dictionary allowing the user to lookup any instance using any name","title":"Class Attributes"},{"location":"docs/MainFiles/GameObject/GameObject/#instance-attributes","text":"Attribute discription name The name this game object will be referenced by screen The instance of the screen loaded from the screen sprite The file path of the sprite to load from the data folder parent Transforms the game object to this game object's local scale packages All the user made or builtin packages in the scripts folder to put in for this game object","title":"Instance Attributes"},{"location":"docs/MainFiles/GameObject/GameObject/#auto-set","text":"Attribute discription image_start The original image loaded from data with no transforms on it package_instances list of all the instances of packages to turn them into attributes parent_instance the instance of the parent game object to access its transform and other key values","title":"Auto-set"},{"location":"docs/MainFiles/GameObject/GameObject/#methods","text":"Method discription init sets most class attributes and imports scripts start Initializes the sprite and loads the instance of the parent also calls the start method in all scripts update called each frame from the MainGameLoop will call update method in all scripts fixed_update called each physicsFrame , will have eventual consistency so it is good for physics, calls fixed_update method in all scripts on_collision_enter called by the collision handler, calls on_collision_enter for the scripts on_trigger_enter same as collision enter but for trigger boxes _import_class_from_string takes in two strings containing the file path for the script, either from builtins or user folders, returns the instance of the script specified by the input string. will search the user folder first then the builtins. _pyLoad takes in the file path of the image stored in the data folder and returns the image loaded using pyGame and the convert_alpha() method to make it transparent so it doesnt show up as a rectangle","title":"Methods"},{"location":"docs/MainFiles/GameObject/GameObject/#instantiating-the-class","text":"","title":"Instantiating the class"},{"location":"docs/MainFiles/GameObject/GameObject/#to-instantiate-the-class-the-arguments-are-passed-in-as-follows","text":"Attribute Result name string of the name that the game object will be called in the dictionary of all game objects screen should be the same for all game objects, screen.screen, from when the screen was instantiated. This is where the game object will be rendered sprite file name of the image that you want displayed for the game object. No need to put the full filepath, just make sure to put the image in the data folder. parent By default, this is set to origin, which causes all inputs to directly transform to screen cords. this is the name of the game object you wish to have as the parent if you want one. args all the scripts you want to add to the game object","title":"To instantiate the class, the arguments are passed in as follows:"},{"location":"docs/MainFiles/GameObject/Attributes/classAttributes/","text":"GAME_OBJECTS INSTANCES and NAMES instance and names are lists game_objects is a dictionary during init, Names will be appended with just the name put in by the user when defining the game object. Instances will just have self appended to the list. Neither of these are particuarly useful but they are used to append this information to GAME_OBJECTS. GAME_OBJECTS is a dictionary which contains the instances of the classes keyed to the names given by the user to be called like a variable but also allows up to iterate through every game object instance. This is useful for calling functions like start, update and fixed_update. #calling every instance of the game objects from pyEngine2D.game_object import GameObject for object in GameObject.INSTANCES: object.start() #Sample from variables while instantiating the game object from pyEngine2D.game_object import GameObject as GO GO.GAME_OBJECTS[\"katz\"].Transform.rotation = 0","title":"GAME_OBJECTS INSTANCES and NAMES"},{"location":"docs/MainFiles/GameObject/Attributes/classAttributes/#game_objects-instances-and-names","text":"instance and names are lists game_objects is a dictionary during init, Names will be appended with just the name put in by the user when defining the game object. Instances will just have self appended to the list. Neither of these are particuarly useful but they are used to append this information to GAME_OBJECTS. GAME_OBJECTS is a dictionary which contains the instances of the classes keyed to the names given by the user to be called like a variable but also allows up to iterate through every game object instance. This is useful for calling functions like start, update and fixed_update. #calling every instance of the game objects from pyEngine2D.game_object import GameObject for object in GameObject.INSTANCES: object.start() #Sample from variables while instantiating the game object from pyEngine2D.game_object import GameObject as GO GO.GAME_OBJECTS[\"katz\"].Transform.rotation = 0","title":"GAME_OBJECTS INSTANCES and NAMES"},{"location":"docs/MainFiles/GameObject/Attributes/InstanceAttributes/packages/","text":"Packages and Scripts These will be how the main code that the user writes will be called. in the init function, it will import the scripts requested by the user, when instantiating the game object. It will then make two versions of the string, one that has the builtins folder in scripts as the destination adn one with the user folder. then it calls _import_class_from_string to get an instance of that class. it then will add that instance to the package_instances attribute, which are used for every method call. When calling a method, for example the update method, it will iterate through everything in package_instances and try to call the update method in the script. the script does not need to have an update method and if it doesn't, then nothing happens and it will carry on without errors. for p in self.package_instances: try: p.update() except AttributeError as e: if \"object has no attribute 'update'\" in str(e): pass else: raise e Making a new script Inside the scripts folder, there is a folder called \"user.\" make a new python file called whatever you want and make a new class in it. It is possible to have multiple classes in the same file like with collisions, where all the collider and collision handler classes are in one file but can be independently put on to different game objects. Inside the new class, the init method requires two arguments, self and game_object. Self is self-explanatory. game_object is parsed in when the class is instantiated by each instance of game object. This is to allow you to check and change attributes in the game object itself as well as in other scripts attached to the game object. #calling the image_start attribute from the game object instance that has this instance of Transform. self.game_object.image_start To recive events, there are builtin and user made (not added yet) events that are called by the game object for every attached script. One example is the update function which is called once a frame. When it is called, the main game loop calls the update function for every game object, which then calls the update function for each attached script. More indepth descriptions of the possible events are elsewhere in the documentation. When adding these functions only pass in self as an argument and make sure the method name is spelled correctly. def update(self): self.load = self._f_scale() Adding the script to different game objects. When first instantiating any game object, there are an indeterminate amount of packages that can be added. After the \"parent\" argument, the rest of the instantiation can be used for the packages. When naming the script it is only required to call the name of the file and the name of the class, not the full file path. GO(\"katz\", screen.screen, \"null.png\", \"origin\", \"transform.Transform\", \"Collider2D.RectangleCollider2D\", \"player_movement.PlayerMovement\") Once it is instantiated, the script's instance is set as an attribute for the game object with the name being the name of the class. As stated above, this will only pass in self and game_object. To pass in additional arguments, you need to call the instance of the class and individually set each attribute. This is also where the GAME_OBJECTS class attribute comes in, because to call each game object, you just call the name input earlier as the key for the dictionary. GO.GAME_OBJECTS[\"katz\"].Transform.rotation = 0","title":"Packages and Scripts"},{"location":"docs/MainFiles/GameObject/Attributes/InstanceAttributes/packages/#packages-and-scripts","text":"These will be how the main code that the user writes will be called. in the init function, it will import the scripts requested by the user, when instantiating the game object. It will then make two versions of the string, one that has the builtins folder in scripts as the destination adn one with the user folder. then it calls _import_class_from_string to get an instance of that class. it then will add that instance to the package_instances attribute, which are used for every method call. When calling a method, for example the update method, it will iterate through everything in package_instances and try to call the update method in the script. the script does not need to have an update method and if it doesn't, then nothing happens and it will carry on without errors. for p in self.package_instances: try: p.update() except AttributeError as e: if \"object has no attribute 'update'\" in str(e): pass else: raise e","title":"Packages and Scripts"},{"location":"docs/MainFiles/GameObject/Attributes/InstanceAttributes/packages/#making-a-new-script","text":"Inside the scripts folder, there is a folder called \"user.\" make a new python file called whatever you want and make a new class in it. It is possible to have multiple classes in the same file like with collisions, where all the collider and collision handler classes are in one file but can be independently put on to different game objects. Inside the new class, the init method requires two arguments, self and game_object. Self is self-explanatory. game_object is parsed in when the class is instantiated by each instance of game object. This is to allow you to check and change attributes in the game object itself as well as in other scripts attached to the game object. #calling the image_start attribute from the game object instance that has this instance of Transform. self.game_object.image_start To recive events, there are builtin and user made (not added yet) events that are called by the game object for every attached script. One example is the update function which is called once a frame. When it is called, the main game loop calls the update function for every game object, which then calls the update function for each attached script. More indepth descriptions of the possible events are elsewhere in the documentation. When adding these functions only pass in self as an argument and make sure the method name is spelled correctly. def update(self): self.load = self._f_scale()","title":"Making a new script"},{"location":"docs/MainFiles/GameObject/Attributes/InstanceAttributes/packages/#adding-the-script-to-different-game-objects","text":"When first instantiating any game object, there are an indeterminate amount of packages that can be added. After the \"parent\" argument, the rest of the instantiation can be used for the packages. When naming the script it is only required to call the name of the file and the name of the class, not the full file path. GO(\"katz\", screen.screen, \"null.png\", \"origin\", \"transform.Transform\", \"Collider2D.RectangleCollider2D\", \"player_movement.PlayerMovement\") Once it is instantiated, the script's instance is set as an attribute for the game object with the name being the name of the class. As stated above, this will only pass in self and game_object. To pass in additional arguments, you need to call the instance of the class and individually set each attribute. This is also where the GAME_OBJECTS class attribute comes in, because to call each game object, you just call the name input earlier as the key for the dictionary. GO.GAME_OBJECTS[\"katz\"].Transform.rotation = 0","title":"Adding the script to different game objects."},{"location":"docs/MainFiles/GameObject/Attributes/InstanceAttributes/parent/","text":"Parent Sets the frame of reference for the object to be rendered. by default the parent is pre-set as \"origin\" which has the scale set at 1, rotation to 0 and transform to 0,0 This makes it so whatever number is input for any of these values is 1:1 transformed to the screen. There are cases however, like making an arm on a body, which require multiple game objects to move across the screen without changing in relation to one another. this allows the user to do this by just moving or otherwise transforming the parent, and all the children will move by the same amount. For the most part, the parent is only by default used in the transform script, but it is possible to use the parent/child relation to transfer any information from the parent to the child. #Here, the if statement checks if the parent's scale or the child's scale has changed and if so scales it using the _parent_scale method to scale the gameobject using both the game object and the parent's scale values. # in self.game_object.parent_instance.Transform.scale, it follows, like a file path, the road to the value. # it goes to the instance of the parent game object, helpfully stored in parent_instance, then goes to the instance of the Transform class inside that game object using the Transform attribute then grabs the scale from that. if self.game_object.parent_instance.Transform.scale != self.last_parent_scale or self.scale != self.last_scale: self.previous_scale = self._parent_scale() self.last_parent_scale = self.game_object.parent_instance.Transform.previous_scale","title":"Parent"},{"location":"docs/MainFiles/GameObject/Attributes/InstanceAttributes/parent/#parent","text":"Sets the frame of reference for the object to be rendered. by default the parent is pre-set as \"origin\" which has the scale set at 1, rotation to 0 and transform to 0,0 This makes it so whatever number is input for any of these values is 1:1 transformed to the screen. There are cases however, like making an arm on a body, which require multiple game objects to move across the screen without changing in relation to one another. this allows the user to do this by just moving or otherwise transforming the parent, and all the children will move by the same amount. For the most part, the parent is only by default used in the transform script, but it is possible to use the parent/child relation to transfer any information from the parent to the child. #Here, the if statement checks if the parent's scale or the child's scale has changed and if so scales it using the _parent_scale method to scale the gameobject using both the game object and the parent's scale values. # in self.game_object.parent_instance.Transform.scale, it follows, like a file path, the road to the value. # it goes to the instance of the parent game object, helpfully stored in parent_instance, then goes to the instance of the Transform class inside that game object using the Transform attribute then grabs the scale from that. if self.game_object.parent_instance.Transform.scale != self.last_parent_scale or self.scale != self.last_scale: self.previous_scale = self._parent_scale() self.last_parent_scale = self.game_object.parent_instance.Transform.previous_scale","title":"Parent"},{"location":"docs/MainFiles/GameObject/Methods/PackageFunctionCalls/","text":"Package Method Calls Collisions on_collision Only called if both game objects have is_trigger set to false. Will stop the game objects from phasing through each other once they start to collide. Will pass in other which is the other game object in that collision. Enter Called on both game objects involved in a collision, only on the physics frame that they start to collide. Stay Same as enter, called each physics frame that the two game objects stay together. Exit same as enter, called on the physics frame that the game objects stop touching. on trigger Only called if one of the game obejcts in the collision has is_trigger set to true. If both colliders have it set to true, then nothing happens. This will not stop the game objects from going through each other. Will pass in other which is the other game object in that collision. On trigger has the same 3 methods as on collision just as \"on_trigger_enter\" not \"on_collision_enter\"","title":"Package Method Calls"},{"location":"docs/MainFiles/GameObject/Methods/PackageFunctionCalls/#package-method-calls","text":"","title":"Package Method Calls"},{"location":"docs/MainFiles/GameObject/Methods/PackageFunctionCalls/#collisions","text":"","title":"Collisions"},{"location":"docs/MainFiles/GameObject/Methods/PackageFunctionCalls/#on_collision","text":"Only called if both game objects have is_trigger set to false. Will stop the game objects from phasing through each other once they start to collide. Will pass in other which is the other game object in that collision.","title":"on_collision"},{"location":"docs/MainFiles/GameObject/Methods/PackageFunctionCalls/#enter","text":"Called on both game objects involved in a collision, only on the physics frame that they start to collide.","title":"Enter"},{"location":"docs/MainFiles/GameObject/Methods/PackageFunctionCalls/#stay","text":"Same as enter, called each physics frame that the two game objects stay together.","title":"Stay"},{"location":"docs/MainFiles/GameObject/Methods/PackageFunctionCalls/#exit","text":"same as enter, called on the physics frame that the game objects stop touching.","title":"Exit"},{"location":"docs/MainFiles/GameObject/Methods/PackageFunctionCalls/#on-trigger","text":"Only called if one of the game obejcts in the collision has is_trigger set to true. If both colliders have it set to true, then nothing happens. This will not stop the game objects from going through each other. Will pass in other which is the other game object in that collision. On trigger has the same 3 methods as on collision just as \"on_trigger_enter\" not \"on_collision_enter\"","title":"on trigger"},{"location":"docs/MainFiles/GameObject/Methods/TimedFunctionCalls/","text":"Timed events All of these events happen automatically on a set timer. Almost always called from the main game loop. start called before the game loop starts running. Used as a second init in case you want to make sure something is instantiated before you do something with it. fixed_update Called with eventual consistently. This means that over time the fixed_update will be called the same amount no matter (to an extent) how slow the computer running the game is. This stops a sprite from moving incredibly slow or fast because of someone's computer. This works by, every loop of the main game loop, it will check how long since the last time it reached the fixed_update method then stay in that loop until the fixed_update has caught up to where is should have been at by that point in the code when it first reached the fixed_update method. update unlike fixed_update, this will change depending on the computer's speed. It will always be called once per game loop. This is the cause of lag spikes if the fixed_update falls too far behind.","title":"Timed events"},{"location":"docs/MainFiles/GameObject/Methods/TimedFunctionCalls/#timed-events","text":"All of these events happen automatically on a set timer. Almost always called from the main game loop.","title":"Timed events"},{"location":"docs/MainFiles/GameObject/Methods/TimedFunctionCalls/#start","text":"called before the game loop starts running. Used as a second init in case you want to make sure something is instantiated before you do something with it.","title":"start"},{"location":"docs/MainFiles/GameObject/Methods/TimedFunctionCalls/#fixed_update","text":"Called with eventual consistently. This means that over time the fixed_update will be called the same amount no matter (to an extent) how slow the computer running the game is. This stops a sprite from moving incredibly slow or fast because of someone's computer. This works by, every loop of the main game loop, it will check how long since the last time it reached the fixed_update method then stay in that loop until the fixed_update has caught up to where is should have been at by that point in the code when it first reached the fixed_update method.","title":"fixed_update"},{"location":"docs/MainFiles/GameObject/Methods/TimedFunctionCalls/#update","text":"unlike fixed_update, this will change depending on the computer's speed. It will always be called once per game loop. This is the cause of lag spikes if the fixed_update falls too far behind.","title":"update"},{"location":"docs/Tutorial/Introduction/","text":"Tutorial What you will accoumplish By the end you will build a screensaver bouncing around the screen with the python logo. To do this you will: 1: Load the image into the data directory 2: Instantiate a game object with the transform builtin and the image from the data directory 3: Write a user script to make the image bounce around the screen","title":"Tutorial"},{"location":"docs/Tutorial/Introduction/#tutorial","text":"","title":"Tutorial"},{"location":"docs/Tutorial/Introduction/#what-you-will-accoumplish","text":"By the end you will build a screensaver bouncing around the screen with the python logo. To do this you will: 1: Load the image into the data directory 2: Instantiate a game object with the transform builtin and the image from the data directory 3: Write a user script to make the image bounce around the screen","title":"What you will accoumplish"},{"location":"docs/Tutorial/LoadingAndInstantiating/","text":"Loading and Instantiating the game object First we need to get our image for this tutorial we will use the python logo: Get this image or another online and download it as a png or jpg. Once done place the image in the data folder of pyEngine2D next to null.png. Instantiating the game object. Then in the variables.py file, add a line: GO(\"Logo\", screen.screen, \"logo.png\", \"origin\", \"transform.Transform\", \"bounce.Bounce\") This line starts by giving the game object the name: Logo . It then sets the object to render on the correct pyGame screen and sets the image to render as the name of the image you just put into the data folder. the origin argument makes the parent origin so all the transforms are 1:1 to the screen. Finally, we add the transform.Transform which allows you to move the object around the screen. Next we need to start the game object at the center of the screen. To do this we go into the game object and into the Transform package and from there to the transform variable. (this can be confusing but lower case transform is the coords on the screen and uppercase Transform is the entire package) GO.GAME_OBJECTS[\"Logo\"].Transform.transform = [180, 240] We enter the GAME_OBJECTS dictionary in game_objects, GO, and call the key: Logo. We can access the attributes of that game object for example here we are calling the attribute Transform which is the instance of the Transform script for that game object. The points 180 and 240 are just half way across the screen to center the game object. We now have a game object that will be rendered to the center of the screen but will not move at all. Depending on the image, it may fill up too much of the screen and if so we can scale it down by, just like with the transform, accessing the attribute from the game object.","title":"Loading and Instantiating the game object"},{"location":"docs/Tutorial/LoadingAndInstantiating/#loading-and-instantiating-the-game-object","text":"First we need to get our image for this tutorial we will use the python logo: Get this image or another online and download it as a png or jpg. Once done place the image in the data folder of pyEngine2D next to null.png.","title":"Loading and Instantiating the game object"},{"location":"docs/Tutorial/LoadingAndInstantiating/#instantiating-the-game-object","text":"Then in the variables.py file, add a line: GO(\"Logo\", screen.screen, \"logo.png\", \"origin\", \"transform.Transform\", \"bounce.Bounce\") This line starts by giving the game object the name: Logo . It then sets the object to render on the correct pyGame screen and sets the image to render as the name of the image you just put into the data folder. the origin argument makes the parent origin so all the transforms are 1:1 to the screen. Finally, we add the transform.Transform which allows you to move the object around the screen. Next we need to start the game object at the center of the screen. To do this we go into the game object and into the Transform package and from there to the transform variable. (this can be confusing but lower case transform is the coords on the screen and uppercase Transform is the entire package) GO.GAME_OBJECTS[\"Logo\"].Transform.transform = [180, 240] We enter the GAME_OBJECTS dictionary in game_objects, GO, and call the key: Logo. We can access the attributes of that game object for example here we are calling the attribute Transform which is the instance of the Transform script for that game object. The points 180 and 240 are just half way across the screen to center the game object. We now have a game object that will be rendered to the center of the screen but will not move at all. Depending on the image, it may fill up too much of the screen and if so we can scale it down by, just like with the transform, accessing the attribute from the game object.","title":"Instantiating the game object."},{"location":"docs/Tutorial/MakingAScript/","text":"Making a script We now have a game object that can render onto the screen, but it does not move. Our script will now add that. To make the script we need to go into pyEngine2D/scripts/user. In here let's make a script: bounce.py. Inside the file let's start by importing two packages. These are not nessesary to this script we are writing but are for bigger files so it is good to add them. from pyEngine2D.game_object import GameObject import pygame We first need an the init function with two arguments: self and game_object. Any attributes that need to be added we can do that seperatly after instantiating the game object. def __init__(self, game_object): self.game_object = game_object Now because we are just rendering this and do not care about percise movements, we are going to put the code into the update method. Before that however, we will make two instance attributes: x_speed and y_speed. These can be changed in the variables file like how we changed the transform value. # y is set to negative because we want to start with it going to the top right corner and (0,0) is in the top left. def start(self): self.x_speed = 5 self.y_speed = -5 Now for update we will need code to move the image and some more to check if the image is bouncing out of the screen. The movement is quite easy, we just need to call the add_transform method in Transform. # it takes in the x and y value to move it by so we can just add the speed values. self.game_object.Transform.add_transform(self.x_speed, self.y_speed) Next to check if the image goes off the screen. To do this, we need to check if the image's x or y is less than 0 because then the image would be off the screen to the left/top. Then to check for the right/bottom, we will grab the width value for screen from the screen class. With this information we can do a simple check to see if it is out. if (self.game_object.Transform.transform[0] < 0 or self.game_object.Transform.transform[0] > self.game_object.screen.width): self.x_speed = -self.x_speed #reverses the horizontal direction of the go Then we just need to do the same thing for the y-axis elif (self.game_object.Transform.transform[1] < 0 or self.game_object.Transform.transform[1] > self.game_object.screen.height): self.y_speed = -self.y_speed And were done now when you run it, it should show: Adding a gif when I get home.","title":"Making a script"},{"location":"docs/Tutorial/MakingAScript/#making-a-script","text":"We now have a game object that can render onto the screen, but it does not move. Our script will now add that. To make the script we need to go into pyEngine2D/scripts/user. In here let's make a script: bounce.py. Inside the file let's start by importing two packages. These are not nessesary to this script we are writing but are for bigger files so it is good to add them. from pyEngine2D.game_object import GameObject import pygame We first need an the init function with two arguments: self and game_object. Any attributes that need to be added we can do that seperatly after instantiating the game object. def __init__(self, game_object): self.game_object = game_object Now because we are just rendering this and do not care about percise movements, we are going to put the code into the update method. Before that however, we will make two instance attributes: x_speed and y_speed. These can be changed in the variables file like how we changed the transform value. # y is set to negative because we want to start with it going to the top right corner and (0,0) is in the top left. def start(self): self.x_speed = 5 self.y_speed = -5 Now for update we will need code to move the image and some more to check if the image is bouncing out of the screen. The movement is quite easy, we just need to call the add_transform method in Transform. # it takes in the x and y value to move it by so we can just add the speed values. self.game_object.Transform.add_transform(self.x_speed, self.y_speed) Next to check if the image goes off the screen. To do this, we need to check if the image's x or y is less than 0 because then the image would be off the screen to the left/top. Then to check for the right/bottom, we will grab the width value for screen from the screen class. With this information we can do a simple check to see if it is out. if (self.game_object.Transform.transform[0] < 0 or self.game_object.Transform.transform[0] > self.game_object.screen.width): self.x_speed = -self.x_speed #reverses the horizontal direction of the go Then we just need to do the same thing for the y-axis elif (self.game_object.Transform.transform[1] < 0 or self.game_object.Transform.transform[1] > self.game_object.screen.height): self.y_speed = -self.y_speed And were done now when you run it, it should show: Adding a gif when I get home.","title":"Making a script"}]}